<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CloneFest 2025: Minigolf</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
        }
        #ui-container {
            position: absolute;
            top: 1rem;
            left: 1rem;
        }
        #message-box {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            min-width: 300px;
            text-align: center;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">
    <!-- UI elements (Your responsibility) -->
    <div id="ui-container" class="space-y-2 p-4 bg-gray-800 bg-opacity-75 rounded-xl shadow-lg border-2 border-gray-700">
        <div id="hole-number" class="text-lg font-bold">Hole: 1</div>
        <div id="strokes" class="text-lg font-bold">Strokes: 0</div>
    </div>
    
    <!-- This is the message box for game feedback (e.g., "Hole Completed!") -->
    <div id="message-box" class="p-3 rounded-md text-white shadow-lg bg-green-500"></div>

    <script type="module">
        let scene, camera, renderer, controls;
        let golfBall, hole;

        // Variables for drag/input logic (from Person 2's role)
        let golfBallVelocity = new THREE.Vector3();
        let isDragging = false;
        let dragStartMouse = new THREE.Vector2();
        let dragLine;
        let powerIndicator;
        let strokes = 0;
        
        // UI elements (from Person 1's role)
        const messageBox = document.getElementById('message-box');
        const strokesText = document.getElementById('strokes');

        // Function to show feedback messages
        function showMessage(message, colorClass = "bg-green-500") {
            messageBox.textContent = message;
            messageBox.className = `p-3 rounded-md text-white shadow-lg transition-opacity duration-300 ${colorClass}`;
            messageBox.style.opacity = '1';
            setTimeout(() => {
                messageBox.style.opacity = '0';
            }, 3000);
        }

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 15);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // OrbitControls for camera
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            // Ground model (a simple, flat course for now)
            const groundGeometry = new THREE.BoxGeometry(20, 0.5, 10);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x55aa55 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.position.y = -0.25;
            scene.add(ground);
            
            // Hole model (made with a cylinder)
            const holeGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 32);
            const holeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            hole = new THREE.Mesh(holeGeometry, holeMaterial);
            hole.position.set(8, 0, 0);
            scene.add(hole);

            // Golf ball
            const ballGeometry = new THREE.SphereGeometry(0.25, 32, 32);
            const ballMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            golfBall = new THREE.Mesh(ballGeometry, ballMaterial);
            golfBall.position.set(-8, 0.25, 0);
            scene.add(golfBall);

            // TODO: Your code goes here
            // Visual aids for aiming and power
            const dragMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            const dragGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
            dragLine = new THREE.Line(dragGeometry, dragMaterial);
            scene.add(dragLine);

            const powerGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const powerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            powerIndicator = new THREE.Mesh(powerGeometry, powerMaterial);
            powerIndicator.position.set(0, 0, 0);
            powerIndicator.visible = false;
            scene.add(powerIndicator);

            // Event listeners for player controls (from Person 2's role)
            window.addEventListener('mousedown', onMouseDown, false);
            window.addEventListener('mouseup', onMouseUp, false);
            window.addEventListener('mousemove', onMouseMove, false);

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Functions for game physics and interaction logic (from Person 2's role)
        function onMouseDown(event) {
            // Do not allow a new shot if the ball is still moving
            if (golfBallVelocity.length() > 0.01) return;
            isDragging = true;
            dragStartMouse.set(event.clientX, event.clientY);
        }

        function onMouseMove(event) {
            if (!isDragging) return;

            const currentMouse = new THREE.Vector2(event.clientX, event.clientY);
            const dragDistance = dragStartMouse.distanceTo(currentMouse);
            const power = Math.min(dragDistance / 100, 10);
            
            // Project mouse position to a 3D plane for aiming
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObject(scene.children.find(child => child.geometry.type === "BoxGeometry")); // Find the ground plane
            if (intersects.length > 0) {
                const intersectPoint = intersects[0].point;
                const direction = new THREE.Vector3().subVectors(intersectPoint, golfBall.position).normalize();

                // Draw the line from the ball
                const points = [
                    golfBall.position,
                    new THREE.Vector3().addVectors(golfBall.position, direction.multiplyScalar(power))
                ];
                dragLine.geometry.setFromPoints(points);

                // Position and show power indicator
                powerIndicator.visible = true;
                powerIndicator.position.copy(golfBall.position);
                powerIndicator.position.y += power / 2;
                powerIndicator.scale.y = power;
            }
        }

        function onMouseUp(event) {
            if (!isDragging || golfBallVelocity.length() > 0.01) {
                isDragging = false;
                dragLine.geometry.setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
                powerIndicator.visible = false;
                return;
            }

            const currentMouse = new THREE.Vector2(event.clientX, event.clientY);
            const dragDistance = dragStartMouse.distanceTo(currentMouse);
            const power = Math.min(dragDistance / 100, 10);

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObject(scene.children.find(child => child.geometry.type === "BoxGeometry"));
            if (intersects.length > 0) {
                const intersectPoint = intersects[0].point;
                const direction = new THREE.Vector3().subVectors(intersectPoint, golfBall.position).normalize();

                // Apply velocity to the ball
                golfBallVelocity = direction.multiplyScalar(power);
                strokes++;
                strokesText.textContent = `Strokes: ${strokes}`;
                showMessage(`Stroke #${strokes}`, "bg-blue-500");
            }
            isDragging = false;
            dragLine.geometry.setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
            powerIndicator.visible = false;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Update physics (from Person 2's role)
            if (golfBallVelocity.length() > 0.01) {
                golfBall.position.add(golfBallVelocity);
                golfBallVelocity.multiplyScalar(0.98);

                // Check if the ball has stopped
                if (golfBallVelocity.length() < 0.01) {
                    golfBallVelocity.set(0, 0, 0);

                    // Check for goal detection
                    const distanceToHole = golfBall.position.distanceTo(hole.position);
                    if (distanceToHole < 0.5) {
                        showMessage("Hole Completed! Good job!", "bg-green-500");
                    }
                }
            }

            // Update camera controls (Your responsibility)
            controls.update();

            renderer.render(scene, camera);
        }

        window.onload = function() {
            init();
        };
    </script>
</body>
</html>
