<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>CloneFest 2025 — Minigolf</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            background: #0b1220;
            color: #fff;
            font-family: Inter, system-ui, Arial;
        }

        canvas {
            display: block
        }

        #ui {
            position: absolute;
            left: 1rem;
            top: 1rem;
            background: rgba(2, 6, 23, 0.75);
            padding: 0.7rem;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.06);
        }

        #ui div {
            margin: 0.2rem 0;
            font-weight: 600;
        }

        #message {
            position: absolute;
            left: 50%;
            bottom: 1.25rem;
            transform: translateX(-50%);
            background: rgba(16, 185, 129, 0.95);
            color: #021;
            padding: 0.6rem 1rem;
            border-radius: 8px;
            opacity: 0;
            transition: opacity .3s ease-in-out;
            font-weight: 700;
        }

        #centerMenu {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: rgba(3, 7, 18, 0.9);
            padding: 1rem 1.25rem;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        button {
            background: #2563eb;
            color: white;
            border: none;
            padding: .5rem .75rem;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer
        }

        button:active {
            transform: translateY(1px)
        }

        .small {
            font-size: 0.85rem;
            color: #bcd;
            font-weight: 500
        }
    </style>
</head>

<body>
    <div id="ui">
        <div id="holeText">Hole: 1 (Par 3)</div>
        <div id="strokesText">Strokes: 0</div>
        <div id="scoreText">Total Score: 0</div>
        <div id="playerText" class="small">Player ID: Guest</div>
    </div>

    <div id="message">Message</div>

    <div id="centerMenu">
        <h2 style="margin:0 0 .5rem 0;">CloneFest 2025 — Minigolf</h2>
        <div class="small" style="margin-bottom:.5rem">Click & drag on the ground to aim & set power.</div>
        <button id="startBtn">Start Hole 1</button>
        <button id="nextBtn" style="margin-left:.6rem; display:none">Next Hole</button>
    </div>

    <script type="module">
        // Modern Three.js module imports (no build step)
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/controls/OrbitControls.js';
        // Firebase imports are optional and used only if __firebase_config is provided
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        setLogLevel('debug');

        // ---------- UI ----------
        const holeText = document.getElementById('holeText');
        const strokesText = document.getElementById('strokesText');
        const scoreText = document.getElementById('scoreText');
        const playerText = document.getElementById('playerText');
        const messageBox = document.getElementById('message');
        const centerMenu = document.getElementById('centerMenu');
        const startBtn = document.getElementById('startBtn');
        const nextBtn = document.getElementById('nextBtn');

        function showMessage(msg, ms = 2200) {
            messageBox.textContent = msg;
            messageBox.style.opacity = '1';
            setTimeout(() => messageBox.style.opacity = '0', ms);
        }

        // ---------- Simple Level Data (2 core holes + optional 3rd) ----------
        const levelData = [
            {
                hole: 1, par: 3,
                ballStart: new THREE.Vector3(-8, 0.25, 0),
                holePos: new THREE.Vector3(8, 0.15, 0),
                groundSize: new THREE.Vector3(22, 0.5, 12),
                terrain: []
            },
            {
                hole: 2, par: 4,
                ballStart: new THREE.Vector3(0, 0.25, -8),
                holePos: new THREE.Vector3(0, 0.15, 8),
                groundSize: new THREE.Vector3(14, 0.5, 22),
                terrain: []
            },
            // Bonus hole with a bump
            {
                hole: 3, par: 5,
                ballStart: new THREE.Vector3(-10, 0.25, 0),
                holePos: new THREE.Vector3(10, 0.15, 0),
                groundSize: new THREE.Vector3(30, 0.5, 16),
                terrain: [{ pos: new THREE.Vector3(0, 1.5, 0), size: new THREE.Vector3(8, 3, 8) }]
            }
        ];

        // ---------- Scene ----------
        let scene, camera, renderer, controls;
        let ambientLight, dirLight;
        let groundMesh, ballMesh, holeMesh;
        let dragLine, powerIndicator, trajGroup;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // physics state
        let ballVelocity = new THREE.Vector3(0, 0, 0);
        let isDragging = false;
        let dragStart = new THREE.Vector2();
        let strokes = 0;
        let totalScore = 0;
        let currentHole = 1;

        // firebase optional
        let app, db, auth, userId;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app';
        const firebaseConfig = (typeof __firebase_config !== 'undefined' && __firebase_config) ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : undefined;

        // ---------- Initialization ----------
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
            camera.position.set(0, 14, 18);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(innerWidth, innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(6, 12, 6);
            scene.add(ambientLight, dirLight);

            // drag visuals
            dragLine = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]),
                new THREE.LineBasicMaterial({ color: 0x00ff00 })
            );
            scene.add(dragLine);

            powerIndicator = new THREE.Mesh(
                new THREE.CylinderGeometry(0.06, 0.06, 1, 8),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            powerIndicator.visible = false;
            scene.add(powerIndicator);

            trajGroup = new THREE.Group();
            scene.add(trajGroup);

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointermove', onPointerMove);
            renderer.domElement.addEventListener('pointerup', onPointerUp);

            startBtn.addEventListener('click', () => loadHole(1));
            nextBtn.addEventListener('click', () => loadHole(currentHole + 1));
        }

        // ---------- Level loader ----------
        function clearLevel() {
            // remove everything except lights and helpers
            scene.children.slice().forEach(child => {
                if (child === ambientLight || child === dirLight || child === dragLine || child === powerIndicator || child === trajGroup) return;
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                    else child.material.dispose();
                }
                scene.remove(child);
            });
            // clear trajectory points
            trajGroup.children.slice().forEach(c => { if (c.geometry) c.geometry.dispose(); scene.remove(c); trajGroup.remove(c); });
        }

        function loadHole(holeNum) {
            clearLevel();
            const level = levelData.find(l => l.hole === holeNum);
            if (!level) {
                showMessage('No more holes — Game Over! Final Score: ' + totalScore, 4000);
                return;
            }
            currentHole = holeNum;
            strokes = 0;
            ballVelocity.set(0, 0, 0);
            holeText.textContent = `Hole: ${currentHole} (Par ${level.par})`;
            strokesText.textContent = `Strokes: ${strokes}`;
            scoreText.textContent = `Total Score: ${totalScore}`;

            // ground (use plane as big box)
            const gGeo = new THREE.BoxGeometry(level.groundSize.x, level.groundSize.y, level.groundSize.z);
            const gMat = new THREE.MeshStandardMaterial({ color: 0x55aa55 });
            groundMesh = new THREE.Mesh(gGeo, gMat);
            groundMesh.position.y = -level.groundSize.y / 2;
            scene.add(groundMesh);

            // hole (small cylinder sunk slightly below ground plane top)
            const holeGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.05, 32);
            const holeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            holeMesh = new THREE.Mesh(holeGeo, holeMat);
            holeMesh.position.copy(level.holePos);
            holeMesh.position.y = 0.02;
            scene.add(holeMesh);

            // golf ball
            const ballGeo = new THREE.SphereGeometry(0.25, 32, 32);
            const ballMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            ballMesh = new THREE.Mesh(ballGeo, ballMat);
            ballMesh.position.copy(level.ballStart);
            ballMesh.position.y = 0.25;
            scene.add(ballMesh);

            // optional terrain blocks
            for (const t of (level.terrain || [])) {
                const tg = new THREE.BoxGeometry(t.size.x, t.size.y, t.size.z);
                const tm = new THREE.MeshStandardMaterial({ color: 0x66bb66 });
                const mesh = new THREE.Mesh(tg, tm);
                mesh.position.copy(t.pos);
                scene.add(mesh);
            }

            // hide menu
            centerMenu.style.display = 'none';
            nextBtn.style.display = 'none';
        }

        // ---------- Input / Aiming ----------
        function getGroundIntersection(clientX, clientY) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            // intersect groundMesh - important: we only want ground intersection
            const intersects = raycaster.intersectObject(groundMesh, true);
            return intersects.length ? intersects[0].point.clone() : null;
        }

        function onPointerDown(e) {
            if (!ballMesh) return;
            // ignore if ball is moving
            if (ballVelocity.length() > 0.05) return;
            isDragging = true;
            dragStart.set(e.clientX, e.clientY);
        }

        function onPointerMove(e) {
            if (!isDragging || !ballMesh) return;
            const hit = getGroundIntersection(e.clientX, e.clientY);
            if (!hit) return;
            // direction from ball to hit
            const dir = new THREE.Vector3().subVectors(hit, ballMesh.position);
            dir.y = 0;
            if (dir.length() < 0.0001) return;
            dir.normalize();
            // power based on pointer displacement
            const dragDist = dragStart.distanceTo(new THREE.Vector2(e.clientX, e.clientY));
            const power = Math.min(dragDist / 100, 12);
            const endPoint = new THREE.Vector3().addVectors(ballMesh.position, dir.clone().multiplyScalar(power));
            dragLine.geometry.setFromPoints([ballMesh.position.clone(), endPoint.clone()]);
            powerIndicator.visible = true;
            powerIndicator.position.copy(ballMesh.position);
            powerIndicator.position.y = 0.35 + Math.min(power / 6, 1.2);
            powerIndicator.scale.set(1, Math.max(0.2, power / 2), 1);
            updateTrajectory(ballMesh.position.clone(), dir.clone().multiplyScalar(power * 0.12));
        }

        function onPointerUp(e) {
            if (!isDragging || !ballMesh) return;
            isDragging = false;
            dragLine.geometry.setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
            powerIndicator.visible = false;
            clearTrajectory();
            // compute power & apply
            const dragDist = dragStart.distanceTo(new THREE.Vector2(e.clientX, e.clientY));
            const power = Math.min(dragDist / 100, 12);
            const hit = getGroundIntersection(e.clientX, e.clientY);
            if (!hit) return;
            const dir = new THREE.Vector3().subVectors(hit, ballMesh.position);
            dir.y = 0;
            if (dir.length() < 0.0001) return;
            dir.normalize();
            ballVelocity.copy(dir.multiplyScalar(power * 0.12)); // feel multiplier
            strokes++;
            totalScore++;
            strokesText.textContent = `Strokes: ${strokes}`;
            scoreText.textContent = `Total Score: ${totalScore}`;
            showMessage(`Stroke #${strokes}`, 1600);
        }

        // ---------- Trajectory preview ----------
        function clearTrajectory() {
            trajGroup.children.slice().forEach(c => { if (c.geometry) c.geometry.dispose(); trajGroup.remove(c); });
        }
        function updateTrajectory(startPos, velocity) {
            clearTrajectory();
            const dt = 0.05;
            let pos = startPos.clone();
            let vel = velocity.clone();
            for (let i = 0; i < 25; i++) {
                pos = pos.clone().add(vel.clone().multiplyScalar(dt));
                vel.multiplyScalar(0.98);
                const dot = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 6), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
                dot.position.copy(pos);
                trajGroup.add(dot);
            }
        }

        // ---------- Physics & animate ----------
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.05);

            // integrate ball velocity
            if (ballMesh && ballVelocity.lengthSq() > 1e-5) {
                // move scaled by delta (frame-rate independent)
                const step = ballVelocity.clone().multiplyScalar(delta * 60);
                ballMesh.position.add(step);

                // friction per second (0.88 -> strong friction; 0.95 -> light)
                const frictionPerSecond = 0.9;
                const f = Math.pow(frictionPerSecond, delta * 60);
                ballVelocity.multiplyScalar(f);

                // clamp
                if (ballVelocity.length() < 0.01) {
                    ballVelocity.set(0, 0, 0);
                    // check goal
                    if (holeMesh && ballMesh.position.distanceTo(holeMesh.position) < 0.6) {
                        onHoleComplete();
                    }
                }
                // keep ball on top of ground
                ballMesh.position.y = 0.25;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function onHoleComplete() {
            showMessage('Hole Completed! Great job!', 2500);
            // show navigator menu and next button or end
            centerMenu.style.display = 'block';
            nextBtn.style.display = (currentHole < levelData.length) ? 'inline-block' : 'none';
            startBtn.style.display = 'none';
            // simple persist (firebase optional)
            if (db && userId) saveScore();
            // update menu title
            centerMenu.querySelector('h2').textContent = `Hole ${currentHole} Completed!`;
            if (currentHole >= 2) {
                // after hole 2 offer end-of-game
                centerMenu.querySelector('.small').textContent = 'You completed core requirements!';
            } else {
                centerMenu.querySelector('.small').textContent = 'Press Next Hole to continue';
            }
        }

        // ---------- Firebase optional ----------
        async function setupFirebase() {
            if (!firebaseConfig) {
                playerText.textContent = 'Player ID: Guest';
                return;
            }
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                await new Promise(resolve => {
                    onAuthStateChanged(auth, user => {
                        if (user) {
                            userId = user.uid;
                            playerText.textContent = `Player ID: ${userId}`;
                        } else {
                            userId = `guest_${crypto.randomUUID()}`;
                            playerText.textContent = 'Player ID: Guest';
                        }
                        resolve();
                    });
                });
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                    userId = auth.currentUser.uid;
                    playerText.textContent = `Player ID: ${userId}`;
                } else {
                    await signInAnonymously(auth);
                    userId = auth.currentUser.uid;
                    playerText.textContent = `Player ID: ${userId}`;
                }
                // load existing score if any
                if (db && userId) {
                    const scoreRef = doc(db, `artifacts/${appId}/users/${userId}/scores/minigolf_score`);
                    const snap = await getDoc(scoreRef);
                    if (snap.exists()) {
                        totalScore = snap.data().totalScore || 0;
                        scoreText.textContent = `Total Score: ${totalScore}`;
                    }
                }
            } catch (err) {
                console.warn('Firebase init failed:', err);
            }
        }
        async function saveScore() {
            if (!db || !userId) return;
            try {
                const scoreRef = doc(db, `artifacts/${appId}/users/${userId}/scores/minigolf_score`);
                await setDoc(scoreRef, { totalScore });
            } catch (err) {
                console.error('saveScore error', err);
            }
        }

        // ---------- Window resize ----------
        function onWindowResize() {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        }

        // ---------- Boot ----------
        init();
        animate();
        setupFirebase(); // optional

        // load initial menu state (Start)
        // Start button will load hole 1 (done already in listener). If you want auto-start, uncomment:
        // loadHole(1);

    </script>
</body>

</html>